---
title: Support Vector Machines
layout: default
output: bookdown::html_chapter
---

# Chapter 12, Support Vector Machines

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="Ch12-figures/")
```

This goal of this chapter is to create an interactive data
visualization that explains the
[Support Vector Machine](https://en.wikipedia.org/wiki/Support_vector_machine),
a machine learning model for binary classification.

```{r}
library(data.table)
N <- 100
set.seed(1)
getInput <- function(){
  rnorm(N, 0, 1)
}
sqInput <- function(x){
  x * x
}
data.dt <- data.table(
  x1=getInput(),
  x2=getInput())
data.dt[, x1.sq := sqInput(x1) ]
data.dt[, x2.sq := sqInput(x2) ]
data.dt[, f := x1^2 + x2^2]
data.dt[, noise := rnorm(N, 0, 0.5)]
data.dt[, f.noise := f+noise]
true.decision.boundary <- 1
data.dt[, y := factor(ifelse(f.noise<true.decision.boundary, -1, 1))]
train.i <- 1:(N/2)
train.dt <- data.dt[train.i,]
test.dt <- data.dt[-train.i,]
```

```{r}
x.min <- -2
x.max <- 2
n.grid <- 40
x.vec <- seq(x.min, x.max, l=n.grid)
grid.dt <- data.table(expand.grid(
  x1=x.vec,
  x2=x.vec))
grid.dt[, f := x1^2 + x2^2 ]
input.space <- ggplot()+
  geom_contour(aes(x1, x2, z=f),
               breaks=true.decision.boundary,
               data=grid.dt)+
  geom_point(aes(x1, x2, color=y),
             shape=21,
             fill=NA,
             data=train.dt)
input.space
```

```{r}
x.sq.vec <- seq(0, x.max^2, l=n.grid)
grid.sq.dt <- data.table(expand.grid(
  x1.sq=x.sq.vec,
  x2.sq=x.sq.vec))
grid.sq.dt[, f := x1.sq + x2.sq ]
squared.space <- ggplot()+
  geom_contour(aes(x1.sq, x2.sq, z=f),
               breaks=true.decision.boundary,
               size=1,
               color="red",
               data=grid.sq.dt)+
  geom_point(aes(x1.sq, x2.sq, color=y),
             shape=21,
             fill=NA,
             data=train.dt)
squared.space

```

```{r}
library(kernlab)
squared.mat <- train.dt[, cbind(x1.sq, x2.sq)]
y.vec <- train.dt$y
cost.param <- 1
fit <- ksvm(squared.mat, y.vec, kernel="vanilladot", scaled=TRUE, C=cost.param)
fit.sc <- scaling(fit)$x.scale
mu <- fit.sc[["scaled:center"]]
sigma <- fit.sc[["scaled:scale"]]
predF <- function(fit, X){
  X.sc <- scale(X, mu, sigma)
  kernelMult(kernelf(fit), X.sc, xmatrix(fit)[[1]], coef(fit)[[1]])-b(fit)
}
weight.vec <- colSums(xmatrix(fit)[[1]]*coef(fit)[[1]])
predF2 <- function(fit, X){
  X.sc <- scale(X, mu, sigma)
  X.sc %*% weight.vec - b(fit)
}
grid.sq.dt[, pred.f := predF(fit, cbind(x1.sq, x2.sq))]
train.dt[, pred.f := predF(fit, cbind(x1.sq, x2.sq))]
train.dt[, pred.f2 := predF2(fit, cbind(x1.sq, x2.sq))]
train.dt[, pred.y := predict(fit, cbind(x1.sq, x2.sq))]
grid.dt[, x1.sq := x1^2]
grid.dt[, x2.sq := x2^2]
grid.dt[, pred.f := predF(fit, cbind(x1.sq, x2.sq))]
train.dt$alpha <- 0
train.dt[as.integer(rownames(xmatrix(fit)[[1]])), alpha := alpha(fit)[[1]]]
train.dt[, status := ifelse(
  alpha==0, "alpha=0",
  ifelse(alpha==cost.param, "alpha=C", "0<alpha<C"))]
## The equation of the margin lines is x2 = m2 + s2/w2[c+b+w1*m1/s1]
## -s2*w1/(w2*s1)*x1 for c=1 and -1. x is input feature, m is mean, s
## is scale, w is learned weight.
slack.slope <- weight.vec[2]*sigma[1]/(weight.vec[1]*sigma[2])
abline.dt <- data.table(
  y=factor(c(-1,0,1)),
  intercept=mu[2]+sigma[2]/weight.vec[2]*(
    c(-1, 0, 1)+b(fit)+weight.vec[1]*mu[1]/sigma[1]),
  slope=-weight.vec[1]*sigma[2]/(weight.vec[2]*sigma[1]))
setkey(abline.dt, y)
slack.dt <- train.dt[alpha==cost.param,]
setkey(slack.dt, y)
slack.join <- abline.dt[slack.dt]
slack.join[, x1.sq.margin := (
  x2.sq-slack.slope*x1.sq-intercept)/(slope-slack.slope)]
slack.join[, x2.sq.margin := slope*x1.sq.margin + intercept]
squared.space+
  coord_equal()+
  geom_abline(aes(slope=slope, intercept=intercept),
              color="green",
              linetype="dotted",
              data=abline.dt)+
  geom_segment(aes(x1.sq, x2.sq,
                   xend=x1.sq.margin, yend=x2.sq.margin),
               color="grey",
               data=slack.join)+
  geom_contour(aes(x1.sq, x2.sq, z=pred.f),
               breaks=0,
               color="black",
               data=grid.sq.dt)+
  geom_contour(aes(x1.sq, x2.sq, z=pred.f),
               breaks=c(-1, 1),
               color="black",
               linetype="dashed",
               data=grid.sq.dt)

sv.colors <- c(
  "alpha=0"="white",
  "0<alpha<C"="black",
  "alpha=C"="grey")
ggplot()+
  geom_contour(aes(x1.sq, x2.sq, z=f),
               breaks=true.decision.boundary,
               size=1,
               color="red",
               data=grid.sq.dt)+
  geom_point(aes(x1.sq, x2.sq, color=y, fill=status),
             shape=21,
             data=train.dt)+
  scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
  geom_segment(aes(x1.sq, x2.sq,
                   xend=x1.sq.margin, yend=x2.sq.margin),
               color="grey",
               data=slack.join)+
  geom_contour(aes(x1.sq, x2.sq, z=pred.f),
               breaks=0,
               color="black",
               data=grid.sq.dt)+
  geom_contour(aes(x1.sq, x2.sq, z=pred.f),
               breaks=c(-1, 1),
               color="black",
               linetype="dashed",
               data=grid.sq.dt)

ggplot()+
  geom_point(aes(x1, x2, color=y, fill=status),
             shape=21,
             data=train.dt)+
  scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
  geom_contour(aes(x1, x2, z=f),
               breaks=true.decision.boundary,
               data=grid.dt)+
  geom_contour(aes(x1, x2, z=pred.f),
               breaks=0,
               color="black",
               data=grid.dt)+
  geom_contour(aes(x1, x2, z=pred.f),
               breaks=c(-1, 1),
               color="black",
               linetype="dashed",
               data=grid.dt)

```
