---
title: Support Vector Machines
layout: default
output: bookdown::html_chapter
---

# Chapter 12, Support Vector Machines

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.path="Ch12-figures/")
```

This goal of this chapter is to create an interactive data
visualization that explains the
[Support Vector Machine](https://en.wikipedia.org/wiki/Support_vector_machine),
a machine learning model for binary classification.

## Generate and plot some data

We begin by generating two input features, `x1` and `x2`.

```{r}
library(data.table)
N <- 100
set.seed(1)
getInput <- function(){
  runif(N, -1, 1)
}
data.dt <- data.table(
  x1=getInput(),
  x2=getInput())
ggplot()+
  geom_point(aes(x1, x2),
             data=data.dt)
```

The plot below shows the same data, after computing two additional
input features (the squares of the original two inputs).

```{r}
data.dt[, x1.sq := x1^2 ]
data.dt[, x2.sq := x2^2 ]
ggplot()+
  geom_point(aes(x1.sq, x2.sq),
             data=data.dt)
```

In our simulation, we assume that the output score `f` is a linear
function of `x1.sq`, and ignores `x2.sq`. The plot below visualizes
the output scores using the point fill aesthetic.

```{r}
data.dt[, f := x1.sq]
true.decision.boundary <- 0.2
ggplot()+
  theme_bw()+
  scale_fill_gradient2(midpoint=true.decision.boundary)+
  geom_point(aes(x1.sq, x2.sq, fill=f),
             shape=21,
             color="grey",
             data=data.dt)
```

In particular, we assume that the label `y` is negative (-1) if
`x1.sq + noise < 0.2`, and positive (1) otherwise. The plot below
visualizes the scores and labels, as a function of the input feature
`x1`. It also shows the true score function in black.

```{r}
data.dt[, f.noise := f+rnorm(N, 0, 0.1)]
data.dt[, y.num := ifelse(f.noise<true.decision.boundary, -1, 1)]
data.dt[, y := factor(y.num)]
scores <- data.table(x1=seq(-1, 1, l=101))
scores[, x1.sq := x1^2 ]
scores[, f := x1.sq ]
x1.boundaries <- data.table(boundary=c(1, -1)*sqrt(true.decision.boundary))
ggplot()+
  scale_y_continuous(breaks=seq(0, 1, by=0.2))+
  geom_vline(aes(xintercept=boundary), color="grey50", data=x1.boundaries)+
  geom_line(aes(x1, f), data=scores)+
  geom_point(aes(x1, f.noise, color=y),
             shape=21,
             fill=NA,
             data=data.dt)
```

The plot below shows the scores and labels, as a function of the
squared feature `x1.sq`. It is clear that the score function that we
want to learn is linear in `x1.sq`.

```{r}
x1sq.boundary <- data.table(boundary=0.2)
ggplot()+
  scale_y_continuous(breaks=seq(0, 1, by=0.2))+
  scale_x_continuous(breaks=seq(0, 1, by=0.2))+
  geom_vline(aes(xintercept=boundary), color="grey50", data=x1sq.boundary)+
  geom_line(aes(x1.sq, f), data=scores)+
  geom_point(aes(x1.sq, f.noise, color=y),
             shape=21,
             fill=NA,
             data=data.dt)
```

Next, we visualize the labels in the two-dimensional squared feature
space. It is clear that the decision boundary is linear in this space.

```{r}
table(data.dt$y)
ggplot()+
  scale_y_continuous(breaks=seq(0, 1, by=0.2))+
  scale_x_continuous(breaks=seq(0, 1, by=0.2))+
  geom_vline(aes(xintercept=boundary), color="grey50", data=x1sq.boundary)+
  geom_point(aes(x1.sq, x2.sq, color=y),
             shape=21,
             fill=NA,
             data=data.dt)
```

The plot below shows the input feature space (`x1` and `x2`). It is
clear that the decision boundary is non-linear in `x1`.

```{r}
ggplot()+
  scale_y_continuous(breaks=seq(-1, 1, by=0.2))+
  scale_x_continuous(breaks=seq(-1, 1, by=0.2))+
  geom_vline(aes(xintercept=boundary), color="grey50", data=x1.boundaries)+
  geom_point(aes(x1, x2, color=y),
             shape=21,
             fill=NA,
             data=data.dt)
```

The animint below uses `clickSelects` to show which points in the
input and squared space correspond. We just need to create an
`observation.i` variable that has a unique ID for each data point.

```{r}
library(animint)
data.dt[, observation.i := 1:.N]
YVAR <- function(dt, y.var){
  dt$y.var <- factor(y.var, c("x2", "x2.sq", "f"))
  dt
}
viz.simple <- list(
  input=ggplot()+
    ggtitle("input feature space")+
    theme_bw()+
    theme(panel.margin=grid::unit(0, "lines"))+
    facet_grid(y.var ~ ., scales="free")+
    scale_x_continuous(breaks=seq(-1, 1, by=0.2))+
    ylab("")+
    guides(color="none")+
    geom_vline(aes(xintercept=boundary),
               color="grey50",
               data=x1.boundaries)+
    geom_point(aes(x1, x2, color=y, clickSelects=observation.i),
               size=4,
               alpha=0.7,
               data=YVAR(data.dt, "x2"))+
    geom_line(aes(x1, f),
              data=YVAR(scores, "f"))+
    geom_point(aes(x1, f.noise, color=y, clickSelects=observation.i),
               size=4,
               alpha=0.7,
               data=YVAR(data.dt, "f")),
  square=ggplot()+
    ggtitle("squared feature space")+
    theme_bw()+
    theme(panel.margin=grid::unit(0, "lines"))+
    facet_grid(y.var ~ ., scales="free")+
    ylab("")+
    scale_x_continuous(breaks=seq(0, 1, by=0.2))+
    geom_vline(aes(xintercept=boundary), color="grey50",
               data=x1sq.boundary)+
    geom_point(aes(x1.sq, x2.sq, color=y, clickSelects=observation.i),
               size=4,
               alpha=0.7,
               data=YVAR(data.dt, "x2.sq"))+
    geom_line(aes(x1.sq, f),
              data=YVAR(scores, "f"))+
    geom_point(aes(x1.sq, f.noise, color=y, clickSelects=observation.i),
               size=4,
               alpha=0.7,
               data=YVAR(data.dt, "f")))
structure(viz.simple, class="animint")
```

Note how we used two multi-panel plots with the
[addColumn then facet](ChXX-appendix.html#addColumn-then-facet) idiom,
rather than creating four separate plots. This emphasizes the fact
that some plots/facets have a common `x1` or `x1.sq` axis. Note that
we also hid the color legend in the first plot, since it is sufficient
to just have one color legend.

### SVM

```{r}
data.dt[, data.i := 1:.N]
train.i <- 1:(N/2)
data.dt[, set := "test"]
data.dt <- data.dt[train.i, set := "train"]
table(data.dt$set)
train.dt <- data.dt[set=="train",]

```

foo

```{r}
grid.dt <- data.table(expand.grid(
  x1=x.vec,
  x2=x.vec))
grid.dt[, f := x1^2 + x2^2 ]
input.space <- ggplot()+
  geom_contour(aes(x1, x2, z=f),
               breaks=true.decision.boundary,
               data=grid.dt)+
  geom_point(aes(x1, x2, color=y),
             shape=21,
             fill=NA,
             data=train.dt)
input.space
```

bar

```{r}
x.sq.vec <- seq(0, x.max^2, l=n.grid)
grid.sq.dt <- data.table(expand.grid(
  x1.sq=x.sq.vec,
  x2.sq=x.sq.vec))
grid.sq.dt[, f := x1.sq + x2.sq ]
squared.space <- ggplot()+
  geom_contour(aes(x1.sq, x2.sq, z=f),
               breaks=true.decision.boundary,
               size=1,
               color="red",
               data=grid.sq.dt)+
  geom_point(aes(x1.sq, x2.sq, color=y),
             shape=21,
             fill=NA,
             data=train.dt)
squared.space

```

```{r}
library(kernlab)
squared.mat <- train.dt[, cbind(x1.sq, x2.sq)]
y.vec <- train.dt$y
getBoundaryDF <- function(score.vec, level.vec=c(-1, 0, 1)){
  stopifnot(length(score.vec) == n.grid * n.grid)
  several.paths <- contourLines(
    x.vec, x.vec,
    matrix(score.vec, n.grid, n.grid),
    levels=level.vec)
  contour.list <- list()
  for(path.i in seq_along(several.paths)){
    contour.list[[path.i]] <- with(several.paths[[path.i]], data.table(
      path.i,
      level.num=as.numeric(level),
      level.fac=factor(level, c(-1, 0, 1)),
      x1=x, x2=y))
  }
  do.call(rbind, contour.list)
}
modelInfo.list <- list()
predictions.list <- list()
slackSegs.list <- list()
modelLines.list <- list()
inputBoundaries.list <- list()
setErrors.list <- list()
cost.by <- 0.1
for(cost.param in 10^seq(-1, 1, by=cost.by)){
  fit <- ksvm(
    squared.mat, y.vec, kernel="vanilladot", scaled=FALSE, C=cost.param)
  fit.sc <- scaling(fit)$x.scale
  if(is.null(fit.sc)){
    fit.sc <- list(
      "scaled:center"=c(0,0),
      "scaled:scale"=c(1,1))
  }
  mu <- fit.sc[["scaled:center"]]
  sigma <- fit.sc[["scaled:scale"]]
  predF <- function(fit, X){
    X.sc <- scale(X, mu, sigma)
    kernelMult(kernelf(fit), X.sc, xmatrix(fit)[[1]], coef(fit)[[1]])-b(fit)
  }
  weight.vec <- colSums(xmatrix(fit)[[1]]*coef(fit)[[1]])
  predF2 <- function(fit, X){
    X.sc <- scale(X, mu, sigma)
    X.sc %*% weight.vec - b(fit)
  }
  grid.sq.dt[, pred.f := predF(fit, cbind(x1.sq, x2.sq))]
  data.dt[, pred.y := predict(fit, cbind(x1.sq, x2.sq))]
  one.error <- data.dt[, list(errors=sum(y!=pred.y)), by=set]
  setErrors.list[[paste(cost.param)]] <- data.table(
    cost.param, one.error)
  train.dt[, pred.f := predF(fit, cbind(x1.sq, x2.sq))]
  train.dt[, pred.f2 := predF2(fit, cbind(x1.sq, x2.sq))]
  train.dt[, pred.y := predict(fit, cbind(x1.sq, x2.sq))]
  grid.dt[, x1.sq := x1^2]
  grid.dt[, x2.sq := x2^2]
  grid.dt[, pred.f := predF(fit, cbind(x1.sq, x2.sq))]
  boundaries <- getBoundaryDF(grid.dt$pred.f)
  inputBoundaries.list[[paste(cost.param)]] <- data.table(
    cost.param, boundaries)
  train.dt$alpha <- 0
  train.dt[as.integer(rownames(xmatrix(fit)[[1]])), alpha := alpha(fit)[[1]]]
  train.dt[, status := ifelse(
    alpha==0, "alpha=0",
    ifelse(alpha==cost.param, "alpha=C", "0<alpha<C"))]
  ## The equation of the margin lines is x2 = m2 + s2/w2[c+b+w1*m1/s1]
  ## -s2*w1/(w2*s1)*x1 for c=1 and -1. x is input feature, m is mean, s
  ## is scale, w is learned weight.
  slack.slope <- weight.vec[2]*sigma[1]/(weight.vec[1]*sigma[2])
  abline.dt <- data.table(
    y=factor(c(-1,0,1)),
    boundary=c("margin", "decision", "margin"),
    intercept=mu[2]+sigma[2]/weight.vec[2]*(
      c(-1, 0, 1)+b(fit)+weight.vec[1]*mu[1]/sigma[1]),
    slope=-weight.vec[1]*sigma[2]/(weight.vec[2]*sigma[1]))
  setkey(abline.dt, y)
  slack.dt <- train.dt[alpha==cost.param,]
  setkey(slack.dt, y)
  slack.join <- abline.dt[slack.dt]
  slack.join[, x1.sq.margin := (
    x2.sq-slack.slope*x1.sq-intercept)/(slope-slack.slope)]
  slack.join[, x2.sq.margin := slope*x1.sq.margin + intercept]
  squared.space+
    coord_equal()+
    geom_abline(aes(slope=slope, intercept=intercept),
                color="green",
                linetype="dotted",
                data=abline.dt)+
    geom_segment(aes(x1.sq, x2.sq,
                     xend=x1.sq.margin, yend=x2.sq.margin),
                 color="grey",
                 data=slack.join)+
    geom_contour(aes(x1.sq, x2.sq, z=pred.f),
                 breaks=0,
                 color="black",
                 data=grid.sq.dt)+
    geom_contour(aes(x1.sq, x2.sq, z=pred.f),
                 breaks=c(-1, 1),
                 color="black",
                 linetype="dashed",
                 data=grid.sq.dt)

  norm.weights <- as.numeric(weight.vec %*% weight.vec)
  modelInfo.list[[paste(cost.param)]] <- data.table(
    cost.param,
    total.slack=slack.join[, sum(1-pred.f*y.num)],
    norm.weights,
    margin.size=2/sqrt(norm.weights))

  predictions.list[[paste(cost.param)]] <- data.table(
    cost.param, train.dt)

  slackSegs.list[[paste(cost.param)]] <- data.table(
    cost.param, slack.join)

  modelLines.list[[paste(cost.param)]] <- data.table(
    cost.param, abline.dt)
  
  sv.colors <- c(
    "alpha=0"="white",
    "0<alpha<C"="black",
    "alpha=C"="grey")
  ggplot()+
    geom_contour(aes(x1.sq, x2.sq, z=f),
                 breaks=true.decision.boundary,
                 size=1,
                 color="red",
                 data=grid.sq.dt)+
    geom_point(aes(x1.sq, x2.sq, color=y, fill=status),
               shape=21,
               data=train.dt)+
    scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
    geom_segment(aes(x1.sq, x2.sq,
                     xend=x1.sq.margin, yend=x2.sq.margin),
                 color="grey",
                 data=slack.join)+
    geom_abline(aes(slope=slope, intercept=intercept, linetype=boundary),
                color="black",
                data=abline.dt)
  ## geom_contour(aes(x1.sq, x2.sq, z=pred.f),
  ##              breaks=0,
  ##              color="black",
  ##              data=grid.sq.dt)+
  ## geom_contour(aes(x1.sq, x2.sq, z=pred.f),
  ##              breaks=c(-1, 1),
  ##              color="black",
  ##              linetype="dashed",
  ##              data=grid.sq.dt)

  ggplot()+
    geom_point(aes(x1, x2, color=y, fill=status),
               shape=21,
               data=train.dt)+
    scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
    geom_contour(aes(x1, x2, z=f),
                 breaks=true.decision.boundary,
                 data=grid.dt)+
    geom_contour(aes(x1, x2, z=pred.f),
                 breaks=0,
                 color="black",
                 data=grid.dt)+
    geom_contour(aes(x1, x2, z=pred.f),
                 breaks=c(-1, 1),
                 color="black",
                 linetype="dashed",
                 data=grid.dt)

}
inputBoundaries <- do.call(rbind, inputBoundaries.list)
predictions <- do.call(rbind, predictions.list)
slackSegs <- do.call(rbind, slackSegs.list)
modelLines <- do.call(rbind, modelLines.list)
modelInfo <- do.call(rbind, modelInfo.list)
setErrors <- do.call(rbind, setErrors.list)

modelInfo.tall <- melt(modelInfo, id.vars="cost.param")

library(animint)
grid.sq.dt$boundary <- "true"
setErrors$variable <- "errors"
viz <- list(
  selectModel=ggplot()+
    ggtitle("select regularization parameter")+
    geom_tallrect(aes(
      xmin=log10(cost.param)-cost.by/2,
      xmax=log10(cost.param)+cost.by/2,
      clickSelects=cost.param),
      alpha=0.5,
      data=modelInfo)+
    theme_bw()+
    theme(panel.margin=grid::unit(0, "lines"))+
    facet_grid(variable ~ ., scales="free")+
    geom_line(aes(log10(cost.param), errors,
                  group=set, color=set),
              data=setErrors)+
    geom_line(aes(log10(cost.param), log10(value)),
              data=modelInfo.tall),
  inputSpace=ggplot()+
    ggtitle("Input space features")+
    scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
    geom_contour(aes(x1, x2, z=f),
                 breaks=true.decision.boundary,
                 color="violet",
                 data=grid.dt)+
    guides(color="none", fill="none")+
    scale_linetype_manual(values=c(
      "-1"="dashed",
      "0"="solid",
      "1"="dashed"))+
    geom_path(aes(x1, x2,
                  group=path.i,
                  linetype=level.fac,
                  showSelected=cost.param),
              color="black",
              data=inputBoundaries)+
    geom_point(aes(x1, x2, color=y, fill=status, showSelected=cost.param,
                   clickSelects=data.i),
               size=3,
               data=predictions),
  kernelSpace=ggplot()+
    ggtitle("Kernel space features")+
    geom_abline(aes(slope=slope, intercept=intercept, linetype=boundary,
                    showSelected=cost.param),
                color="black",
                data=modelLines)+
    scale_linetype_manual(values=c(
      decision="solid",
      margin="dashed",
      true="solid"))+
    ## geom_contour(aes(x1.sq, x2.sq, z=f, linetype=boundary),
    ##              breaks=true.decision.boundary,
    ##              size=2,
    ##              color="violet",
    ##              data=grid.sq.dt)+
    geom_point(aes(x1.sq, x2.sq, color=y, fill=status,
                   clickSelects=data.i,
                   showSelected=cost.param),
               size=3,
               data=predictions)+
    scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
    geom_segment(aes(x1.sq, x2.sq,
                     showSelected=cost.param,
                     xend=x1.sq.margin, yend=x2.sq.margin),
                 color="grey",
                 data=slackSegs))
structure(viz, class="animint")

inputBoundaries[, boundary := ifelse(level.num==0, "decision", "margin")]
slackSegs$boundary <- "margin"
viz.linked <- list(
  selectModel=ggplot()+
    ggtitle("select regularization parameter")+
    geom_tallrect(aes(
      xmin=log10(cost.param)-cost.by/2,
      xmax=log10(cost.param)+cost.by/2,
      clickSelects=cost.param),
      alpha=0.5,
      data=modelInfo)+
    theme_bw()+
    theme(panel.margin=grid::unit(0, "lines"))+
    facet_grid(variable ~ ., scales="free")+
    geom_line(aes(log10(cost.param), errors,
                  group=set, color=set),
              data=setErrors)+
    geom_text(aes(log10(cost.param), errors-1, label=set,
                  color=set),
              hjust=1,
              data=setErrors[cost.param==min(cost.param),])+
    guides(color="none")+
    geom_line(aes(log10(cost.param), log10(value)),
              data=modelInfo.tall),
  inputSpace=ggplot()+
    ggtitle("Input space features")+
    scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
    geom_contour(aes(x1, x2, z=f),
                 breaks=true.decision.boundary,
                 color="violet",
                 data=grid.dt)+
    guides(color="none", fill="none", linetype="none")+
    scale_linetype_manual(values=c(
      "-1"="dashed",
      "0"="solid",
      "1"="dashed"))+
    geom_path(aes(x1, x2,
                  group=path.i,
                  linetype=level.fac,
                  showSelected2=boundary,
                  showSelected=cost.param),
              color="black",
              data=inputBoundaries)+
    geom_point(aes(x1, x2, color=y, fill=status,
                   showSelected4=status,
                   showSelected3=y,
                   showSelected2=data.i,
                   showSelected=cost.param),
               size=5,
               color="grey",
               data=predictions)+
    geom_point(aes(x1, x2, color=y, fill=status,
                   showSelected=cost.param,
                   showSelected4=status,
                   showSelected3=y,
                   clickSelects=data.i),
               size=3,
               data=predictions),
  kernelSpace=ggplot()+
    ggtitle("Kernel space features")+
    geom_abline(aes(slope=slope, intercept=intercept, linetype=boundary,
                    showSelected=cost.param),
                color="black",
                data=modelLines)+
    scale_linetype_manual(values=c(
      decision="solid",
      margin="dashed",
      true="solid"))+
    ## geom_contour(aes(x1.sq, x2.sq, z=f, linetype=boundary),
    ##              breaks=true.decision.boundary,
    ##              size=2,
    ##              color="violet",
    ##              data=grid.sq.dt)+
    geom_point(aes(x1.sq, x2.sq, color=y, fill=status,
                   showSelected2=data.i,
                   showSelected=cost.param),
               size=5,
               color="grey",
               data=predictions)+
    geom_point(aes(x1.sq, x2.sq, color=y, fill=status,
                   clickSelects=data.i,
                   showSelected=cost.param),
               size=3,
               data=predictions)+
    scale_fill_manual(values=sv.colors, breaks=names(sv.colors))+
    geom_segment(aes(x1.sq, x2.sq,
                     showSelected=cost.param,
                     showSelected2=boundary,
                     xend=x1.sq.margin, yend=x2.sq.margin),
                 color="grey",
                 data=slackSegs))
structure(viz.linked, class="animint")

## TODO: add polynomial kernels.

```
